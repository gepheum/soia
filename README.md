# Soia

*Like Protocol Buffer, but better.*

Soia is a language for representing data types, constants and RPC interfaces. Soia files have the `.soia` extension.

```d
// shapes.soia

struct Point {
  x: int32;
  y: int32;
  label: string;
}

struct Polyline {
  points: [Point];
  label: string;
}

const LIMIT: Point = {
  x = 600,
  y = 400,
  label = "Limit",
};
```

The soia compiler takes in a set of soia files and generates source files containg the definition of the data types and constants in various programming languages. It also generates functions for serializing the data types to either JSON or a more compact binary format.

```python
from soiagen import shapes  # source file generated by the soia compiler

point = shapes.Point(x=3, y=4, label="P")
json = shapes.Point.SERIALIZER.to_json(point)
point = shapes.Point.SERIALIZER.from_json(json)
assert(point == shapes.Point(x=3, y=4, label="P"))
```

As of March 2025, soia has official plugins for Javascript/Typescript, Python and C++.

TODO: links

## Language reference

### Records

There are two types of records: structs and enums.

#### Structs

Use the keyword `struct` to define a struct, which is a collection of fields of different types.

The fields of a struct have a name, but during serialization they are actually identified by a number, which can either be set explicitly:

```d
struct Point {
  x: int = 0;
  y: int = 1;
  label: string = 2;
}
```

or implicitly:

```d
struct Point {
  x: int;  // implicitly set to 0
  y: int;  // implicitly set to 1
  label: string;  // implicitly set to 2
}
```

If you're not explicitly specifying the field numbers, you must be careful not to change the order of the fields or else you won't be able to deserialize old values.

```d
// BAD: you can't reorder the fields and keep implicit numbering
struct Point {
  label: string;
  x: int;
  y: int;
}

// GOOD
struct Point {
  label: string = 2;

  // Fine to rename fields
  x_coordinate: int = 0;
  y_coordinate: int = 1;

  // Fine to add new fields
  color: Color = 3;
}
```

#### Enums

Enums in Soia are similar to enums in Rust. An enum value is one of several possible variants, and each variant can optionally have data associated with it.

```d
// Indicates whether an operation succeeded or failed.
enum OperationStatus {
  SUCCESS;  // a constant field
  error: string;  // a value field
}
```

In this example, an `OperationStatus` is one of these 3 things:

*   the `SUCCESS` constant
*   an `error` with a string value
*   `UNKNOWN`: a special implicit variant common to all enums

If you need a variant to hold multiple values, wrap them inside a struct:

```d
struct MoveAction {
  x: int32;
  y: int32;
}

enum BoardGameTurn {
  PASS;
  move: MoveAction;
}
```

Like structs, the fields of an enum have a number, and the numbering can be explicit or implicit.

```d
enum ExplicitNumbering {
  // The numbers don't need to be consecutive.
  FOO = 10;
  bar: string = 2;
}

enum ImplicitNumbering {
  // Implicit numbering is 1-based.
  // 0 is reserved for the special UNKNOWN variant.

  FOO;  // = 1
  bar: string;  // = 2
}
```

The fields numbers are used for identifying the variants in the serialization format (not the field names). You must be careful not to change the number of a field, or you won't be able to deserialize old values. For example, if you're using implicit numbering, you must not reorder the fields.

It is always fine to rename an enum, rename the fields of an enum, or add new fields to an enum.

#### Nesting records

You can define a record (struct or enum) within the definition of another record. This is simply for namespacing, and it can help make your soia files more organized.

```d
enum Status {
  OK;

  struct Error {
    message: string;
  }
  error: Error;
}

struct Foo {
  // Note the dot notation to refer to the nested record.
  error: Status.Error;
}
```

#### Removed fields

When removing a field from a struct or an enum, you must mark the removed number in the record definition. The syntax is different whether you're using explicit or implicit numbering:

```d
struct ExplicitNumbering {
  a: string = 0;
  b: string = 1:
  d: string = 3;
  removed 2, 4;
}

struct ImplicitNumbering {
  a: string;
  b: string:
  removed;
  d: string;
  removed;
}
```

### Data types

#### Primitive types

*   `bool`: true or false
*   `int32`: a signed 32-bits integer
*   `int64`: a signed 64-bits integer
*   `uint64`: an unsigned 64-bits integer
*   `float32`: a 32-bits floating point number
*   `float64`: a 64-bits floating point number
*   `string`: a Unicode string
*   `bytes`: a sequence of bytes
*   `timestamp`: a specific instant in time represented as an integral number of milliseconds since the Unix epoch, from 100M days before the Unix epoch to 100M days after the Unix epoch

#### Array type

`[item_type]` represents an array of items.

##### Keyed arrays

If `item_type` is a struct and one of its fields can be used to identify every item in the array, you can add the field name next to a pipe character: `[item_type|key_field]`.

Example:
```d
struct User {
  id: uint64;
  name: string;
}

struct UserRegistry {
  users: [User|id];
}
```

Language plugins will generate methods allowing you to perform key lookups in the array using a hash table. For example, in Python:

```python
user = user_registry.users.find(user_id)
if user:
    do_something(user)
```

If the item key is nested within another struct, you can chain the field names like so: `[item_type|a.b.c]`.

The key type must be a primitive type of an enum type. If it's an enum type, add `.kind` at the end of the key chain:

```d
enum Weekday {
  MONDAY;
  TUESDAY;
  WEDNESDAY;
  THURSDAY;
  FRIDAY;
  SATURDAY;
  SUNDAY;
}

struct WeekdayWorkStatus {
  weekday: Weekday;
  working: bool;
}

struct Employee {
  weekly_schedule: [WeekdayWorkStatus|weekday.kind];
}
```

#### Optional type

Add a question mark at the end of a non-optional type to make it optional. An `other_type?` value is either an `other_type` or null.

### Constants

### Methods

### Imports

## Good practices

Nesting...
Array of structs
Enum of structs
Optional only if want to distinguish with default value...

### Naming

## Serialization formats

When serializing a soia data structure, you can chose one of 3 formats.

### Dense JSON

## VS protos

Consts
Enums and oneof
Maps and keyed items
Timestamp type
Enum and unknown

## Getting started

